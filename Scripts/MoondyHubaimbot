-- Moondy Hub
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library:Notify("Loading Moondy Hub...", 3)

local Window = Library:CreateWindow({
    Title = "Moondy Hub",
    Footer = "version: 1.2",
    Icon = 1,
    NotifySide = "Right",
    ShowCustomCursor = true,
})

local Tabs = {
    Aimbot = Window:AddTab("Aimbot", "CrossHair"),
    Visuals = Window:AddTab("Visuals", "user"),
    World = Window:AddTab("World", "earth"),
    Player = Window:AddTab("Player", "user"),
    Settings = Window:AddTab("Settings", "settings"),
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Vars
local NoLockEnabled = false
local NoLockSmoothness = 0.05
local NoLockFOV = 90
local NoLockTeamCheck = false
local NoLockPart = "Head"
local NoLockWallCheck = false

local ESPEnabled = false
local ESPTeamCheck = false
local ESPBoxes = false
local ESPNames = false
local ESPHealth = false
local RainbowESP = false
local SkeletonESPEnabled = false
local SkeletonTeamCheck = false
local TracersEnabled = false
local TracersTeamCheck = false
local RainbowTracers = false
local ChamsEnabled = false
local ChamsTeamCheck = false
local RainbowChams = false

local HitboxEnabled = false
local HitboxSize = 19
local HitboxTransparency = 0.7

local AutoClickerEnabled = false

local SpeedEnabled = false
local SpeedValue = 20
local JumpEnabled = false
local JumpValue = 50
local InfiniteJumpEnabled = false
local GravityEnabled = false
local GravityValue = 196.2
local NoAirEnabled = false
local Fly2Enabled = false
local Fly2Speed = 50
local InvisEnabled = false
local SpinBotEnabled = false
local SpinSpeed = 20
local NoclipEnabled = false
local PlayerFOV = 70
local XrayEnabled = false

local ESPObjects = {}
local TracerObjects = {}
local ChamsObjects = {}
local SkeletonObjects = {}
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 50
FOVCircle.Filled = false

local BV, BG

-- Death Check
local function isAlive(char)
    char = char or LocalPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0
end

-- Fix: Safe Hitbox Function (Prevents "Object is locked" error)
local function safeSetProperty(instance, prop, value)
    if instance and not instance:IsDescendantOf(LocalPlayer.Character) then
        pcall(function()
            instance[prop] = value
        end)
    end
end

-- Hitbox Expander
RunService.RenderStepped:Connect(function()
    if not isAlive() then return end

    if HitboxEnabled then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and isAlive(player.Character) then
                local hrp = player.Character.HumanoidRootPart
                -- Save original size
                if not hrp:FindFirstChild("OriginalSize") then
                    local orig = Instance.new("Vector3Value")
                    orig.Name = "OriginalSize"
                    orig.Value = hrp.Size
                    orig.Parent = hrp
                end
                
                safeSetProperty(hrp, "Size", Vector3.new(HitboxSize, HitboxSize, HitboxSize))
                safeSetProperty(hrp, "Transparency", HitboxTransparency)
                safeSetProperty(hrp, "Material", Enum.Material.ForceField)
                safeSetProperty(hrp, "CanCollide", false)
            end
        end
    else
        for _, player in pairs(Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local hrp = player.Character.HumanoidRootPart
                local orig = hrp:FindFirstChild("OriginalSize")
                if orig then
                    safeSetProperty(hrp, "Size", orig.Value)
                    orig:Destroy()
                else
                    safeSetProperty(hrp, "Size", Vector3.new(2, 2, 1))
                end
                safeSetProperty(hrp, "Transparency", 1)
                safeSetProperty(hrp, "Material", Enum.Material.Plastic)
            end
        end
    end
end)

-- Auto Clicker (Rapid Fire Fix)
local mouse = LocalPlayer:GetMouse()
mouse.Button1Down:Connect(function()
    if AutoClickerEnabled then
        -- Clicks fast when enabled
        for i = 1, 5 do
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
            task.wait(0.01)
        end
    end
end)

-- NoLock Logic
local function GetNearestTarget()
    if not isAlive() then return nil end
    local nearestTarget = nil
    local shortestDistance = math.huge

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and isAlive(v.Character) then
            local partToAim = v.Character:FindFirstChild(NoLockPart)
            if not partToAim then
                if NoLockPart == "Legs" then partToAim = v.Character:FindFirstChild("LeftLeg") or v.Character:FindFirstChild("Left Leg")
                elseif NoLockPart == "Torso" then partToAim = v.Character:FindFirstChild("UpperTorso") or v.Character:FindFirstChild("Torso")
                else partToAim = v.Character:FindFirstChild("Head") end
            end
            
            if not partToAim then continue end

            local targetPos = partToAim.Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            local mousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

            if onScreen and distance < (NoLockFOV / 2) then
                if NoLockTeamCheck and v.Team == LocalPlayer.Team then continue end

                if NoLockWallCheck then
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
                    local result = workspace:Raycast(Camera.CFrame.Position, (targetPos - Camera.CFrame.Position).Unit * 1000, raycastParams)
                    if result and result.Instance and not result.Instance:IsDescendantOf(v.Character) then continue end
                end

                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestTarget = v
                end
            end
        end
    end
    return nearestTarget
end

local function UpdateFOVCircle()
    FOVCircle.Radius = NoLockFOV
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    FOVCircle.Visible = NoLockEnabled
end

-- ESP Functions (Simplified)
local function UpdateESP()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and not ESPObjects[v] then
            local Box = Drawing.new("Square"); Box.Thickness = 1
            local Name = Drawing.new("Text"); Name.Size = 13; Name.Center = true; Name.Outline = true
            local Health = Drawing.new("Text"); Health.Size = 13; Health.Center = true; Health.Outline = true
            ESPObjects[v] = {Box = Box, Name = Name, Health = Health}
        end
    end
    for _, v in pairs(Players:GetPlayers()) do
        local objects = ESPObjects[v]; if not objects then continue end
        local ShouldShow = false; local color = Color3.new(1, 1, 1)
        if ESPEnabled and isAlive(v.Character) then
            if not (ESPTeamCheck and v.Team == LocalPlayer.Team) then
                local pos, onScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if onScreen then
                    ShouldShow = true
                    if RainbowESP then color = Color3.fromHSV(tick() % 5 / 5, 1, 1) end
                    objects.Box.Size = Vector2.new(30, 60); objects.Box.Position = Vector2.new(pos.X - 15, pos.Y - 30); objects.Box.Color = color
                    objects.Name.Text = v.Name; objects.Name.Position = Vector2.new(pos.X, pos.Y - 40); objects.Name.Color = color
                    objects.Health.Text = math.floor(v.Character.Humanoid.Health); objects.Health.Position = Vector2.new(pos.X, pos.Y - 55); objects.Health.Color = Color3.fromRGB(0, 255, 0)
                end
            end
        end
        objects.Box.Visible = ShouldShow and ESPBoxes; objects.Name.Visible = ShouldShow and ESPNames; objects.Health.Visible = ShouldShow and ESPHealth
    end
end

local function UpdateSkeletonESP()
    for _, line in pairs(SkeletonObjects) do line:Remove() end
    table.clear(SkeletonObjects)
    if not SkeletonESPEnabled then return end

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and isAlive(v.Character) then
            if not (SkeletonTeamCheck and v.Team == LocalPlayer.Team) then
                local hum = v.Character:FindFirstChild("Humanoid")
                if hum then
                    local connections = {
                        {"Head", "UpperTorso"}, {"UpperTorso", "LeftUpperArm"}, {"UpperTorso", "RightUpperArm"},
                        {"LeftUpperArm", "LeftLowerArm"}, {"RightUpperArm", "RightLowerArm"},
                        {"UpperTorso", "LowerTorso"}, {"LowerTorso", "LeftUpperLeg"},
                        {"LowerTorso", "RightUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"},
                        {"RightUpperLeg", "RightLowerLeg"}
                    }
                    local r6_connections = {
                        {"Head", "Torso"}, {"Torso", "Left Arm"}, {"Torso", "Right Arm"},
                        {"Torso", "Left Leg"}, {"Torso", "Right Leg"}
                    }
                    local isR15 = hum.RigType == Enum.HumanoidRigType.R15
                    local selectedConnections = isR15 and connections or r6_connections

                    for _, conn in pairs(selectedConnections) do
                        local part1 = v.Character:FindFirstChild(conn[1])
                        local part2 = v.Character:FindFirstChild(conn[2])
                        if part1 and part2 then
                            local pos1, onScreen1 = Camera:WorldToViewportPoint(part1.Position)
                            local pos2, onScreen2 = Camera:WorldToViewportPoint(part2.Position)
                            if onScreen1 and onScreen2 then
                                local line = Drawing.new("Line")
                                line.Thickness = 1
                                line.Color = RainbowESP and Color3.fromHSV(tick() % 5 / 5, 1, 1) or Color3.new(1, 1, 1)
                                line.From = Vector2.new(pos1.X, pos1.Y)
                                line.To = Vector2.new(pos2.X, pos2.Y)
                                line.Visible = true
                                table.insert(SkeletonObjects, line)
                            end
                        end
                    end
                end
            end
        end
    end
end

local function UpdateTracers()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and not TracerObjects[v] then
            local Line = Drawing.new("Line"); Line.Thickness = 1
            TracerObjects[v] = {Line = Line}
        end
    end
    for _, v in pairs(Players:GetPlayers()) do
        local objects = TracerObjects[v]; if not objects then continue end
        local ShouldShow = false; local color = Color3.new(1, 1, 1)
        if TracersEnabled and isAlive(v.Character) then
            if not (TracersTeamCheck and v.Team == LocalPlayer.Team) then
                local pos, onScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if onScreen then
                    ShouldShow = true
                    local screenPos = Vector2.new(pos.X, pos.Y); local startPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    if RainbowTracers then color = Color3.fromHSV(tick() % 5 / 5, 1, 1) end
                    objects.Line.From = startPos; objects.Line.To = screenPos; objects.Line.Color = color
                end
            end
        end
        objects.Line.Visible = ShouldShow
    end
end

local function UpdateChams()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character then
            if ChamsEnabled and not (ChamsTeamCheck and v.Team == LocalPlayer.Team) and isAlive(v.Character) then
                if not ChamsObjects[v] then
                    local h = Instance.new("Highlight"); h.Name = "NLHighlight"; h.FillTransparency = 0.5; h.Adornee = v.Character; h.Parent = v.Character
                    ChamsObjects[v] = h
                end
                ChamsObjects[v].Enabled = true
                ChamsObjects[v].FillColor = RainbowChams and Color3.fromHSV(tick() % 5 / 5, 1, 1) or Color3.fromRGB(255, 0, 0)
            else
                if ChamsObjects[v] then ChamsObjects[v].Enabled = false end
            end
        end
    end
end

local function SetXray(enable)
    if enable then
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and not v:IsDescendantOf(LocalPlayer.Character) and v:GetAttribute("Xrayed") == nil then
                v:SetAttribute("Xrayed", true)
                v:SetAttribute("OrigTrans", v.Transparency)
                v.Transparency = 0.5
            end
        end
    else
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and v:GetAttribute("Xrayed") then
                local orig = v:GetAttribute("OrigTrans")
                if orig ~= nil then v.Transparency = orig end
                v:SetAttribute("Xrayed", nil)
            end
        end
    end
end

local function UpdateFly2()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    if Fly2Enabled then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then hum.PlatformStand = true end
        if not BV then BV = Instance.new("BodyVelocity"); BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge); BV.Parent = char.HumanoidRootPart end
        if not BG then BG = Instance.new("BodyGyro"); BG.MaxTorque = Vector3.new(math.huge, math.huge, math.huge); BG.P = 10000; BG.Parent = char.HumanoidRootPart end
        
        local moveVec = Vector3.new()
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec - Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec - Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveVec = moveVec + Vector3.new(0, 1, 0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveVec = moveVec - Vector3.new(0, 1, 0) end
        
        BV.Velocity = (moveVec.Magnitude > 0 and moveVec.Unit * Fly2Speed) or Vector3.new(0,0,0)
        BG.CFrame = Camera.CFrame
    else
        if BV then BV:Destroy() BV = nil end
        if BG then BG:Destroy() BG = nil end
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then hum.PlatformStand = false end
    end
end

-- NoLock Loop (Hold Right Click to Lock)
RunService.RenderStepped:Connect(function()
    if not isAlive() then return end
    
    UpdateFOVCircle()
    UpdateESP()
    UpdateTracers()
    UpdateChams()
    UpdateSkeletonESP()
    UpdateFly2()

    -- NoLock Logic (Hold Right Click)
    if NoLockEnabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local target = GetNearestTarget()
        if target then
            local partToAim = target.Character:FindFirstChild(NoLockPart) or target.Character:FindFirstChild("Head")
            if partToAim then
                -- Manipulate CFrame to lock on without moving camera
                local oldCFrame = Camera.CFrame
                Camera.CFrame = CFrame.new(oldCFrame.Position, partToAim.Position)
                task.wait() -- force update
                Camera.CFrame = oldCFrame
            end
        end
    end

    local char = LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid"); local rootPart = char:FindFirstChild("HumanoidRootPart")
        if SpeedEnabled and humanoid and rootPart then rootPart.CFrame = rootPart.CFrame + (humanoid.MoveDirection * ((SpeedValue / 10) * 0.5)) end
        if JumpEnabled and humanoid then humanoid.JumpPower = JumpValue elseif humanoid then humanoid.JumpPower = 50 end
        if GravityEnabled then workspace.Gravity = GravityValue end
        if NoAirEnabled and humanoid and rootPart then local vel = rootPart.Velocity; rootPart.Velocity = Vector3.new(vel.X, 0, vel.Z) end
        if SpinBotEnabled and rootPart then rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0) end
        if NoclipEnabled then for _, v in pairs(char:GetDescendants()) do if v:IsA("BasePart") then v.CanCollide = false end end end
    end
    
    Camera.FieldOfView = PlayerFOV
end)

UserInputService.JumpRequest:Connect(function()
    if InfiniteJumpEnabled and isAlive() then
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then hum:ChangeState("Jumping") end
    end
end)

-- GUI SETUP
local AimbotLeft = Tabs.Aimbot:AddLeftGroupbox("NoLock", "boxes")
AimbotLeft:AddToggle("NoLockEnabled", {Text = "Enable NoLock (Hold RMB)", Default = false, Callback = function(val) NoLockEnabled = val end})
AimbotLeft:AddSlider("NoLockSmoothness", {Text = "Smoothness", Min = 1, Max = 100, Default = 5, Callback = function(val) NoLockSmoothness = val / 100 end})
AimbotLeft:AddSlider("NoLockFOV", {Text = "FOV Size", Min = 10, Max = 500, Default = 90, Callback = function(val) NoLockFOV = val end})
AimbotLeft:AddToggle("FOVCircleEnabled", {Text = "Show FOV Circle", Default = false, Callback = function(val) FOVCircle.Visible = val end})
AimbotLeft:AddDropdown("AimPart", {Values = {"Head", "Torso", "Legs"}, Default = "Head", Callback = function(val) NoLockPart = val end})
AimbotLeft:AddToggle("WallCheck", {Text = "Wall Check", Default = false, Callback = function(val) NoLockWallCheck = val end})
AimbotLeft:AddToggle("TeamCheck", {Text = "Team Check", Default = false, Callback = function(val) NoLockTeamCheck = val end})

local AimbotRight = Tabs.Aimbot:AddRightGroupbox("Extras", "boxes")
AimbotRight:AddToggle("HitboxEnabled", {Text = "Hitbox Expander", Default = false, Callback = function(val) HitboxEnabled = val end})
AimbotRight:AddSlider("HitboxSize", {Text = "Hitbox Size", Min = 1, Max = 50, Default = 19, Callback = function(val) HitboxSize = val end})
AimbotRight:AddToggle("AutoClicker", {Text = "Auto Clicker", Default = false, Callback = function(val) AutoClickerEnabled = val end})

local VisLeft = Tabs.Visuals:AddLeftGroupbox("ESP Settings", "boxes")
VisLeft:AddToggle("ESPEnabled", {Text = "Enable ESP", Default = false, Callback = function(val) ESPEnabled = val end})
VisLeft:AddToggle("ESPBoxes", {Text = "Boxes", Default = false, Callback = function(val) ESPBoxes = val end})
VisLeft:AddToggle("ESPNames", {Text = "Names", Default = false, Callback = function(val) ESPNames = val end})
VisLeft:AddToggle("ESPHealth", {Text = "Health", Default = false, Callback = function(val) ESPHealth = val end})
VisLeft:AddToggle("RainbowESP", {Text = "Rainbow ESP", Default = false, Callback = function(val) RainbowESP = val end})
VisLeft:AddToggle("ESPTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) ESPTeamCheck = val end})

local VisRight = Tabs.Visuals:AddRightGroupbox("World Visuals", "boxes")
VisRight:AddToggle("SkeletonESPEnabled", {Text = "Skeleton ESP", Default = false, Callback = function(val) SkeletonESPEnabled = val end})
VisRight:AddToggle("TracersEnabled", {Text = "Tracers", Default = false, Callback = function(val) TracersEnabled = val end})
VisRight:AddToggle("RainbowTracers", {Text = "Rainbow Tracers", Default = false, Callback = function(val) RainbowTracers = val end})
VisRight:AddToggle("TracersTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) TracersTeamCheck = val end})
VisRight:AddToggle("ChamsEnabled", {Text = "Chams", Default = false, Callback = function(val) ChamsEnabled = val end})
VisRight:AddToggle("RainbowChams", {Text = "Rainbow Chams", Default = false, Callback = function(val) RainbowChams = val end})
VisRight:AddToggle("ChamsTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) ChamsTeamCheck = val end})

local WorldLeft = Tabs.World:AddLeftGroupbox("World", "boxes")
WorldLeft:AddToggle("XrayEnabled", {Text = "Xray", Default = false, Callback = function(val) XrayEnabled = val; SetXray(val) end})
WorldLeft:AddToggle("NightMode", {Text = "Night Mode", Default = false, Callback = function(val) 
    if val then Lighting.TimeOfDay = 0 else Lighting.TimeOfDay = 12 end
end})
WorldLeft:AddButton("Anti Lag (VFX/Textures)", function()
    local count = 0
    for _, v in pairs(game:GetDescendants()) do
        if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Beam") then
            v:Destroy()
            count = count + 1
        elseif v:IsA("Texture") or v:IsA("Decal") then
            v:Destroy()
            count = count + 1
        end
    end
    Library:Notify("Removed " .. count .. " objects", 5)
end)

local PlrLeft = Tabs.Player:AddLeftGroupbox("Visuals", "boxes")
PlrLeft:AddSlider("PlayerFOV", {Text = "FOV", Min = 30, Max = 120, Default = 70, Callback = function(val) PlayerFOV = val end})

local PlrRight = Tabs.Player:AddRightGroupbox("Movement", "boxes")
PlrRight:AddToggle("SpeedEnabled", {Text = "Speed", Default = false, Callback = function(val) SpeedEnabled = val end})
PlrRight:AddSlider("SpeedValue", {Text = "Speed Amount", Min = 1, Max = 999, Default = 20, Callback = function(val) SpeedValue = val end})
PlrRight:AddToggle("InfiniteJumpEnabled", {Text = "Infinite Jump", Default = false, Callback = function(val) InfiniteJumpEnabled = val end})
PlrRight:AddToggle("JumpEnabled", {Text = "Jump Power", Default = false, Callback = function(val) JumpEnabled = val end})
PlrRight:AddSlider("JumpValue", {Text = "Jump Height", Min = 1, Max = 999, Default = 50, Callback = function(val) JumpValue = val end})
PlrRight:AddToggle("GravityEnabled", {Text = "Low Gravity", Default = false, Callback = function(val) 
    GravityEnabled = val
    if val then if GravityValue == 196.2 then GravityValue = 50 end else GravityValue = 196.2; workspace.Gravity = 196.2 end
end})
PlrRight:AddSlider("GravityValue", {Text = "Gravity Amount", Min = 0, Max = 999, Default = 50, Callback = function(val) GravityValue = val; if GravityEnabled then workspace.Gravity = val end end})

local PlrMisc = Tabs.Player:AddLeftGroupbox("Misc", "boxes")
PlrMisc:AddToggle("NoAirEnabled", {Text = "NoAir / Float", Default = false, Callback = function(val) NoAirEnabled = val end})
PlrMisc:AddToggle("Fly2Enabled", {Text = "Fly (Space/Ctrl)", Default = false, Callback = function(val) Fly2Enabled = val end})
PlrMisc:AddSlider("Fly2Speed", {Text = "Fly Speed", Min = 10, Max = 200, Default = 50, Callback = function(val) Fly2Speed = val end})
PlrMisc:AddToggle("SpinBotEnabled", {Text = "SpinBot", Default = false, Callback = function(val) SpinBotEnabled = val end})
PlrMisc:AddSlider("SpinSpeed", {Text = "Spin Speed", Min = 1, Max = 100, Default = 20, Callback = function(val) SpinSpeed = val end})
PlrMisc:AddToggle("NoclipEnabled", {Text = "Noclip", Default = false, Callback = function(val) NoclipEnabled = val end})
PlrMisc:AddLabel("Toggle Invisibility"):AddKeyPicker("InvisKey", {Default = "Z", NoUI = true, Text = "Toggle Invisible (Z)", Mode = "Toggle", Callback = function(Value)
    if Value then
        local char = LocalPlayer.Character
        if char then
            local savedpos = char.HumanoidRootPart.CFrame
            char:MoveTo(Vector3.new(-25.95, 84, 3537.55))
            task.wait(0.15)
            local Seat = Instance.new("Seat", workspace); Seat.Anchored = false; Seat.CanCollide = false; Seat.Name = "invischair"; Seat.Transparency = 1; Seat.Position = Vector3.new(-25.95, 84, 3537.55)
            local Weld = Instance.new("Weld", Seat); Weld.Part0 = Seat; Weld.Part1 = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso"); Seat.CFrame = savedpos
            Library:Notify("Invisible Enabled", 2)
        end
    else
        if workspace:FindFirstChild("invischair") then workspace.invischair:Destroy() end
        Library:Notify("Invisible Disabled", 2)
    end
end})

local SetLeft = Tabs.Settings:AddLeftGroupbox("Utility", "boxes")
SetLeft:AddButton("Serverhop", function()
    local servers = {}
    local page = 1
    while true do
        local success, response = pcall(function()
            return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&sortBy=Players&limit=100&cursor="..(page > 1 and ((page - 1) * 100) or "")))
        end)
        if not success then break end
        for _, server in pairs(response.data) do table.insert(servers, server) end
        if not response.nextPageCursor then break end
        page = page + 1
    end
    if #servers > 0 then TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)].id) end
end)
SetLeft:AddButton("Rejoin", function() TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId) end)
SetLeft:AddButton("Exit", function() game:Shutdown() end)
SetLeft:AddButton("Unload", function() Library:Unload() end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind", "InvisKey", "AimbotKey" })
ThemeManager:SetFolder("MoondyHub")
SaveManager:SetFolder("MoondyHub/Config")
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 0;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;
    Library:SetWatermark((' Moondy Hub | %s fps | %s ms'):format(math.floor(FPS), math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())));
end)

local MenuGroup = Tabs.Settings:AddLeftGroupbox("Menu Keybind", "wrench")
MenuGroup:AddLabel("Toggle UI (K)"):AddKeyPicker("MenuKeybind", { Default = "K", NoUI = false, Text = "Open / Close", Mode = "Toggle" })
MenuGroup:AddLabel("Toggle Aimbot (P)"):AddKeyPicker("AimbotKey", { Default = "P", NoUI = true, Text = "Toggle NoLock", Mode = "Toggle", Callback = function(Value)
    NoLockEnabled = Value
    Toggles.NoLockEnabled.Value = Value
    Options.NoLockEnabled:SetValue(Value)
end})

Library.ToggleKeybind = Options.MenuKeybind
Library:Notify("Loaded Moondy Hub! Hold RMB for NoLock.", 5)

SaveManager:LoadAutoloadConfig()
