-- Moondy Hub
-- Loaded Obsidian Library

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library:Notify("Loading Moondy Hub...", 3)

local Window = Library:CreateWindow({
    Title = "Moondy Hub",
    Footer = "version: 1.0",
    Icon = 1,
    NotifySide = "Right",
    ShowCustomCursor = true,
})

local Tabs = {
    Aimbot = Window:AddTab("Aimbot", "CrossHair"),
    Visuals = Window:AddTab("Visuals", "user"),
    World = Window:AddTab("World", "earth"),
    Player = Window:AddTab("Player", "user"),
    Settings = Window:AddTab("Settings", "settings"),
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local TweenService = game:GetService("TweenService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Vars
local AimbotEnabled = false
local AimbotSmoothness = 1
local AimbotFOV = 90
local AimbotTeamCheck = false
local AimbotPart = "HumanoidRootPart"
local WallCheck = false
local FOVCircleEnabled = false
local FOVSize = 100
local RainbowFOV = false
local AutoShootEnabled = false
local AutoShootTeamCheck = false
local RapidFireEnabled = false

local ESPEnabled = false
local ESPTeamCheck = false
local ESPBoxes = false
local ESPNames = false
local ESPHealth = false
local RainbowESP = false
local SkeletonESPEnabled = false
local SkeletonTeamCheck = false
local TracersEnabled = false
local TracersTeamCheck = false
local RainbowTracers = false
local ChamsEnabled = false
local ChamsTeamCheck = false
local RainbowChams = false

local SpeedEnabled = false
local SpeedValue = 20
local JumpEnabled = false
local JumpValue = 50
local InfiniteJumpEnabled = false
local GravityEnabled = false
local GravityValue = 196.2
local NoAirEnabled = false
local Fly2Enabled = false
local Fly2Speed = 50
local InvisEnabled = false
local SpinBotEnabled = false
local SpinSpeed = 20
local NoclipEnabled = false
local PlayerFOV = 70
local XrayEnabled = false

local ESPObjects = {}
local TracerObjects = {}
local ChamsObjects = {}
local SkeletonObjects = {}
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = false
FOVCircle.Thickness = 1
FOVCircle.NumSides = 50
FOVCircle.Filled = false

local BV, BG

-- Death Check
local function isAlive()
    local char = LocalPlayer.Character
    return char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") and char.Humanoid.Health > 0
end

-- Functions
local function GetNearestTarget()
    if not isAlive() then return nil end
    local nearestTarget = nil
    local shortestDistance = math.huge

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") then
            local partToAim = v.Character:FindFirstChild(AimbotPart)
            if not partToAim then
                if AimbotPart == "Legs" then partToAim = v.Character:FindFirstChild("LeftLeg") or v.Character:FindFirstChild("Left Leg")
                elseif AimbotPart == "Torso" then partToAim = v.Character:FindFirstChild("UpperTorso") or v.Character:FindFirstChild("Torso")
                else partToAim = v.Character:FindFirstChild("Head") end
            end
            
            if not partToAim then continue end

            local targetPos = partToAim.Position
            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPos)
            local mousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude

            if onScreen and distance < (FOVSize / 2) then
                if AimbotTeamCheck and v.Team == LocalPlayer.Team then continue end

                if WallCheck then
                    local raycastParams = RaycastParams.new()
                    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
                    local result = workspace:Raycast(Camera.CFrame.Position, (targetPos - Camera.CFrame.Position).Unit * 1000, raycastParams)
                    if result and result.Instance and not result.Instance:IsDescendantOf(v.Character) then continue end
                end

                if distance < shortestDistance then
                    shortestDistance = distance
                    nearestTarget = v
                end
            end
        end
    end
    return nearestTarget
end

local function UpdateFOVCircle()
    FOVCircle.Radius = FOVSize
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    if RainbowFOV then
        local hue = tick() % 5 / 5
        FOVCircle.Color = Color3.fromHSV(hue, 1, 1)
    else
        FOVCircle.Color = Color3.new(1, 1, 1)
    end
    FOVCircle.Visible = FOVCircleEnabled
end

local function UpdateESP()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and not ESPObjects[v] then
            local Box = Drawing.new("Square"); Box.Thickness = 1
            local Name = Drawing.new("Text"); Name.Size = 13; Name.Center = true; Name.Outline = true
            local Health = Drawing.new("Text"); Health.Size = 13; Health.Center = true; Health.Outline = true
            ESPObjects[v] = {Box = Box, Name = Name, Health = Health}
        end
    end
    for _, v in pairs(Players:GetPlayers()) do
        local objects = ESPObjects[v]; if not objects then continue end
        local ShouldShow = false; local color = Color3.new(1, 1, 1)
        if ESPEnabled and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") then
            if not (ESPTeamCheck and v.Team == LocalPlayer.Team) then
                local pos, onScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if onScreen then
                    ShouldShow = true
                    if RainbowESP then color = Color3.fromHSV(tick() % 5 / 5, 1, 1) end
                    objects.Box.Size = Vector2.new(30, 60); objects.Box.Position = Vector2.new(pos.X - 15, pos.Y - 30); objects.Box.Color = color
                    objects.Name.Text = v.Name; objects.Name.Position = Vector2.new(pos.X, pos.Y - 40); objects.Name.Color = color
                    objects.Health.Text = math.floor(v.Character.Humanoid.Health); objects.Health.Position = Vector2.new(pos.X, pos.Y - 55); objects.Health.Color = Color3.fromRGB(0, 255, 0)
                end
            end
        end
        objects.Box.Visible = ShouldShow and ESPBoxes; objects.Name.Visible = ShouldShow and ESPNames; objects.Health.Visible = ShouldShow and ESPHealth
    end
end

local function UpdateSkeletonESP()
    for _, line in pairs(SkeletonObjects) do line:Remove() end
    table.clear(SkeletonObjects)
    if not SkeletonESPEnabled then return end

    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character then
            if not (SkeletonTeamCheck and v.Team == LocalPlayer.Team) then
                local hum = v.Character:FindFirstChild("Humanoid")
                if hum then
                    local connections = {
                        {"Head", "UpperTorso"}, {"UpperTorso", "LeftUpperArm"}, {"UpperTorso", "RightUpperArm"},
                        {"LeftUpperArm", "LeftLowerArm"}, {"RightUpperArm", "RightLowerArm"},
                        {"UpperTorso", "LowerTorso"}, {"LowerTorso", "LeftUpperLeg"},
                        {"LowerTorso", "RightUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"},
                        {"RightUpperLeg", "RightLowerLeg"}
                    }
                    local r6_connections = {
                        {"Head", "Torso"}, {"Torso", "Left Arm"}, {"Torso", "Right Arm"},
                        {"Torso", "Left Leg"}, {"Torso", "Right Leg"}
                    }
                    local isR15 = hum.RigType == Enum.HumanoidRigType.R15
                    local selectedConnections = isR15 and connections or r6_connections

                    for _, conn in pairs(selectedConnections) do
                        local part1 = v.Character:FindFirstChild(conn[1])
                        local part2 = v.Character:FindFirstChild(conn[2])
                        if part1 and part2 then
                            local pos1, onScreen1 = Camera:WorldToViewportPoint(part1.Position)
                            local pos2, onScreen2 = Camera:WorldToViewportPoint(part2.Position)
                            if onScreen1 and onScreen2 then
                                local line = Drawing.new("Line")
                                line.Thickness = 1
                                line.Color = RainbowESP and Color3.fromHSV(tick() % 5 / 5, 1, 1) or Color3.new(1, 1, 1)
                                line.From = Vector2.new(pos1.X, pos1.Y)
                                line.To = Vector2.new(pos2.X, pos2.Y)
                                line.Visible = true
                                table.insert(SkeletonObjects, line)
                            end
                        end
                    end
                end
            end
        end
    end
end

local function UpdateTracers()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and not TracerObjects[v] then
            local Line = Drawing.new("Line"); Line.Thickness = 1
            TracerObjects[v] = {Line = Line}
        end
    end
    for _, v in pairs(Players:GetPlayers()) do
        local objects = TracerObjects[v]; if not objects then continue end
        local ShouldShow = false; local color = Color3.new(1, 1, 1)
        if TracersEnabled and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Humanoid") then
            if not (TracersTeamCheck and v.Team == LocalPlayer.Team) then
                local pos, onScreen = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                if onScreen then
                    ShouldShow = true
                    local screenPos = Vector2.new(pos.X, pos.Y); local startPos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    if RainbowTracers then color = Color3.fromHSV(tick() % 5 / 5, 1, 1) end
                    objects.Line.From = startPos; objects.Line.To = screenPos; objects.Line.Color = color
                end
            end
        end
        objects.Line.Visible = ShouldShow
    end
end

local function UpdateChams()
    for _, v in pairs(Players:GetPlayers()) do
        if v ~= LocalPlayer and v.Character then
            if ChamsEnabled and not (ChamsTeamCheck and v.Team == LocalPlayer.Team) then
                if not ChamsObjects[v] then
                    local h = Instance.new("Highlight"); h.Name = "NLHighlight"; h.FillTransparency = 0.5; h.Adornee = v.Character; h.Parent = v.Character
                    ChamsObjects[v] = h
                end
                ChamsObjects[v].Enabled = true
                ChamsObjects[v].FillColor = RainbowChams and Color3.fromHSV(tick() % 5 / 5, 1, 1) or Color3.fromRGB(255, 0, 0)
            else
                if ChamsObjects[v] then ChamsObjects[v].Enabled = false end
            end
        end
    end
end

local function SetRapidFire(enabled)
    pcall(function()
        if game:GetService("ReplicatedStorage"):FindFirstChild("Modules") then
            local module = game:GetService("ReplicatedStorage").Modules:FindFirstChild("Client")
            if module then
                local config = module:FindFirstChild("Config")
                if config then
                    local items = config:FindFirstChild("Items")
                    if items then
                        local Items = require(items)
                        for _, data in pairs(Items) do
                            if typeof(data) == "table" and data.RPM then
                                data.RPM = enabled and 9999 or data.RPM
                                if data.ProjectileStats then
                                    data.ProjectileStats.Count = enabled and 5 or 1
                                    data.ProjectileStats.Velocity = enabled and 3000 or data.ProjectileStats.Velocity
                                end
                            end
                        end
                    end
                end
            end
        end
    end)
end

local function SetXray(enable)
    if enable then
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and not v:IsDescendantOf(LocalPlayer.Character) and v:GetAttribute("Xrayed") == nil then
                v:SetAttribute("Xrayed", true)
                v:SetAttribute("OrigTrans", v.Transparency)
                v.Transparency = 0.5
            end
        end
    else
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and v:GetAttribute("Xrayed") then
                local orig = v:GetAttribute("OrigTrans")
                if orig ~= nil then v.Transparency = orig end
                v:SetAttribute("Xrayed", nil)
            end
        end
    end
end

local function UpdateFly2()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return end
    if Fly2Enabled then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then hum.PlatformStand = true end
        if not BV then BV = Instance.new("BodyVelocity"); BV.MaxForce = Vector3.new(math.huge, math.huge, math.huge); BV.Parent = char.HumanoidRootPart end
        if not BG then BG = Instance.new("BodyGyro"); BG.MaxTorque = Vector3.new(math.huge, math.huge, math.huge); BG.P = 10000; BG.Parent = char.HumanoidRootPart end
        
        local moveVec = Vector3.new()
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec - Camera.CFrame.LookVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec - Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + Camera.CFrame.RightVector end
        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveVec = moveVec + Vector3.new(0, 1, 0) end
        if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then moveVec = moveVec - Vector3.new(0, 1, 0) end
        
        BV.Velocity = (moveVec.Magnitude > 0 and moveVec.Unit * Fly2Speed) or Vector3.new(0,0,0)
        BG.CFrame = Camera.CFrame
    else
        if BV then BV:Destroy() BV = nil end
        if BG then BG:Destroy() BG = nil end
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then hum.PlatformStand = false end
    end
end

-- Main Loop
RunService.RenderStepped:Connect(function()
    if not isAlive() then return end
    
    Camera.FieldOfView = PlayerFOV

    if AimbotEnabled then
        local target = GetNearestTarget()
        if target then
            local partToAim = target.Character:FindFirstChild(AimbotPart) or target.Character:FindFirstChild("Head") or target.Character.HumanoidRootPart
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, partToAim.Position), (AimbotSmoothness / 100))
        end
    end
    
    if AutoShootEnabled then
        local ray = Camera:ViewportPointToRay(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        local raycastParams = RaycastParams.new(); raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}; raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        local result = workspace:Raycast(ray.Origin, ray.Direction * 1000, raycastParams)
        if result then
            local char = result.Instance:FindFirstAncestorOfClass("Model")
            if char then
                local plr = Players:GetPlayerFromCharacter(char)
                if plr and plr ~= LocalPlayer and not (AutoShootTeamCheck and plr.Team == LocalPlayer.Team) then
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1); VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
                end
            end
        end
    end

    local char = LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid"); local rootPart = char:FindFirstChild("HumanoidRootPart")
        if SpeedEnabled and humanoid and rootPart then rootPart.CFrame = rootPart.CFrame + (humanoid.MoveDirection * ((SpeedValue / 10) * 0.5)) end
        if JumpEnabled and humanoid then humanoid.JumpPower = JumpValue elseif humanoid then humanoid.JumpPower = 50 end
        if GravityEnabled then workspace.Gravity = GravityValue end
        if NoAirEnabled and humanoid and rootPart then local vel = rootPart.Velocity; rootPart.Velocity = Vector3.new(vel.X, 0, vel.Z) end
        UpdateFly2()
        if SpinBotEnabled and rootPart then rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(SpinSpeed), 0) end
        if NoclipEnabled then for _, v in pairs(char:GetDescendants()) do if v:IsA("BasePart") then v.CanCollide = false end end end
    end
    
    UpdateFOVCircle(); UpdateESP(); UpdateTracers(); UpdateChams(); UpdateSkeletonESP()
end)

UserInputService.JumpRequest:Connect(function()
    if InfiniteJumpEnabled and isAlive() then
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then hum:ChangeState("Jumping") end
    end
end)

-- GUI SETUP
local AimbotLeft = Tabs.Aimbot:AddLeftGroupbox("Aimbot Main", "boxes")
AimbotLeft:AddToggle("AimbotEnabled", {Text = "Enable Aimbot", Default = false, Callback = function(val) AimbotEnabled = val end})
AimbotLeft:AddSlider("AimbotSmoothness", {Text = "Smoothness", Min = 1, Max = 100, Default = 1, Callback = function(val) AimbotSmoothness = val end})
AimbotLeft:AddSlider("FOVSize", {Text = "FOV Size", Min = 10, Max = 500, Default = 90, Callback = function(val) FOVSize = val end})
AimbotLeft:AddToggle("FOVCircleEnabled", {Text = "Show FOV Circle", Default = false, Callback = function(val) FOVCircleEnabled = val end})
AimbotLeft:AddToggle("RainbowFOV", {Text = "Rainbow FOV", Default = false, Callback = function(val) RainbowFOV = val end})
AimbotLeft:AddDropdown("AimPart", {Values = {"Head", "Torso", "Legs", "HumanoidRootPart"}, Default = "HumanoidRootPart", Callback = function(val) 
    if val == 'HumanoidRootPart' then AimbotPart = 'HumanoidRootPart' 
    elseif val == 'Torso' then AimbotPart = 'UpperTorso'
    elseif val == 'Legs' then AimbotPart = 'LeftLeg'
    end
end})
AimbotLeft:AddToggle("WallCheck", {Text = "Wall Check", Default = false, Callback = function(val) WallCheck = val end})
AimbotLeft:AddToggle("AimbotTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) AimbotTeamCheck = val end})

local AimbotRight = Tabs.Aimbot:AddRightGroupbox("Extras", "boxes")
AimbotRight:AddToggle("AutoShoot", {Text = "Auto Shoot", Default = false, Callback = function(val) AutoShootEnabled = val end})
AimbotRight:AddToggle("AutoShootTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) AutoShootTeamCheck = val end})
AimbotRight:AddToggle("RapidFire", {Text = "Rapid Fire", Default = false, Callback = function(val) 
    RapidFireEnabled = val
    SetRapidFire(val)
end})

local VisLeft = Tabs.Visuals:AddLeftGroupbox("ESP Settings", "boxes")
VisLeft:AddToggle("ESPEnabled", {Text = "Enable ESP", Default = false, Callback = function(val) ESPEnabled = val end})
VisLeft:AddToggle("ESPBoxes", {Text = "Boxes", Default = false, Callback = function(val) ESPBoxes = val end})
VisLeft:AddToggle("ESPNames", {Text = "Names", Default = false, Callback = function(val) ESPNames = val end})
VisLeft:AddToggle("ESPHealth", {Text = "Health", Default = false, Callback = function(val) ESPHealth = val end})
VisLeft:AddToggle("RainbowESP", {Text = "Rainbow ESP", Default = false, Callback = function(val) RainbowESP = val end})
VisLeft:AddToggle("ESPTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) ESPTeamCheck = val end})

local VisRight = Tabs.Visuals:AddRightGroupbox("World Visuals", "boxes")
VisRight:AddToggle("SkeletonESPEnabled", {Text = "Skeleton ESP", Default = false, Callback = function(val) SkeletonESPEnabled = val end})
VisRight:AddToggle("TracersEnabled", {Text = "Tracers", Default = false, Callback = function(val) TracersEnabled = val end})
VisRight:AddToggle("RainbowTracers", {Text = "Rainbow Tracers", Default = false, Callback = function(val) RainbowTracers = val end})
VisRight:AddToggle("TracersTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) TracersTeamCheck = val end})
VisRight:AddToggle("ChamsEnabled", {Text = "Chams", Default = false, Callback = function(val) ChamsEnabled = val end})
VisRight:AddToggle("RainbowChams", {Text = "Rainbow Chams", Default = false, Callback = function(val) RainbowChams = val end})
VisRight:AddToggle("ChamsTeamCheck", {Text = "Team Check", Default = false, Callback = function(val) ChamsTeamCheck = val end})

local WorldLeft = Tabs.World:AddLeftGroupbox("World", "boxes")
WorldLeft:AddToggle("XrayEnabled", {Text = "Xray", Default = false, Callback = function(val) XrayEnabled = val; SetXray(val) end})
WorldLeft:AddToggle("NightMode", {Text = "Night Mode", Default = false, Callback = function(val) 
    if val then Lighting.TimeOfDay = 0 else Lighting.TimeOfDay = 12 end
end})
WorldLeft:AddButton("Anti Lag", function()
    for _, v in pairs(game:GetDescendants()) do if v:IsA("Texture") or v:IsA("ParticleEmitter") or v:IsA("Trail") then v:Destroy() end end
    Library:Notify("Cleaned up lag", 5)
end)

local PlrLeft = Tabs.Player:AddLeftGroupbox("Visuals", "boxes")
PlrLeft:AddSlider("PlayerFOV", {Text = "FOV", Min = 30, Max = 120, Default = 70, Callback = function(val) PlayerFOV = val end})

local PlrRight = Tabs.Player:AddRightGroupbox("Movement", "boxes")
PlrRight:AddToggle("SpeedEnabled", {Text = "Speed", Default = false, Callback = function(val) SpeedEnabled = val end})
PlrRight:AddSlider("SpeedValue", {Text = "Speed Amount", Min = 1, Max = 999, Default = 20, Callback = function(val) SpeedValue = val end})
PlrRight:AddToggle("InfiniteJumpEnabled", {Text = "Infinite Jump", Default = false, Callback = function(val) InfiniteJumpEnabled = val end})
PlrRight:AddToggle("JumpEnabled", {Text = "Jump Power", Default = false, Callback = function(val) JumpEnabled = val end})
PlrRight:AddSlider("JumpValue", {Text = "Jump Height", Min = 1, Max = 999, Default = 50, Callback = function(val) JumpValue = val end})
PlrRight:AddToggle("GravityEnabled", {Text = "Low Gravity", Default = false, Callback = function(val) 
    GravityEnabled = val
    if val then if GravityValue == 196.2 then GravityValue = 50 end else GravityValue = 196.2; workspace.Gravity = 196.2 end
end})
PlrRight:AddSlider("GravityValue", {Text = "Gravity Amount", Min = 0, Max = 999, Default = 50, Callback = function(val) GravityValue = val; if GravityEnabled then workspace.Gravity = val end end})

local PlrMisc = Tabs.Player:AddLeftGroupbox("Misc", "boxes")
PlrMisc:AddToggle("NoAirEnabled", {Text = "NoAir / Float", Default = false, Callback = function(val) NoAirEnabled = val end})
PlrMisc:AddToggle("Fly2Enabled", {Text = "Fly (Space/Ctrl)", Default = false, Callback = function(val) Fly2Enabled = val end})
PlrMisc:AddSlider("Fly2Speed", {Text = "Fly Speed", Min = 10, Max = 200, Default = 50, Callback = function(val) Fly2Speed = val end})
PlrMisc:AddToggle("SpinBotEnabled", {Text = "SpinBot", Default = false, Callback = function(val) SpinBotEnabled = val end})
PlrMisc:AddSlider("SpinSpeed", {Text = "Spin Speed", Min = 1, Max = 100, Default = 20, Callback = function(val) SpinSpeed = val end})
PlrMisc:AddToggle("NoclipEnabled", {Text = "Noclip", Default = false, Callback = function(val) NoclipEnabled = val end})
PlrMisc:AddToggle("InvisEnabled", {Text = "Invisible", Default = false, Callback = function(val) 
    if val then
        local char = LocalPlayer.Character
        if char then
            local savedpos = char.HumanoidRootPart.CFrame
            char:MoveTo(Vector3.new(-25.95, 84, 3537.55))
            task.wait(0.15)
            local Seat = Instance.new("Seat", workspace); Seat.Anchored = false; Seat.CanCollide = false; Seat.Name = "invischair"; Seat.Transparency = 1; Seat.Position = Vector3.new(-25.95, 84, 3537.55)
            local Weld = Instance.new("Weld", Seat); Weld.Part0 = Seat; Weld.Part1 = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso"); Seat.CFrame = savedpos
        end
    else
        if workspace:FindFirstChild("invischair") then workspace.invischair:Destroy() end
    end
end})

local SetLeft = Tabs.Settings:AddLeftGroupbox("Utility", "boxes")
SetLeft:AddButton("Serverhop", function()
    local servers = {}
    local page = 1
    while true do
        local success, response = pcall(function()
            return HttpService:JSONDecode(game:HttpGet("https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&sortBy=Players&limit=100&cursor="..(page > 1 and ((page - 1) * 100) or "")))
        end)
        if not success then break end
        for _, server in pairs(response.data) do table.insert(servers, server) end
        if not response.nextPageCursor then break end
        page = page + 1
    end
    if #servers > 0 then TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1, #servers)].id) end
end)
SetLeft:AddButton("Rejoin", function() TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId) end)
SetLeft:AddButton("Unload", function() Library:Unload() end)
SetLeft:AddButton("Exit", function() game:Shutdown() end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
ThemeManager:SetFolder("MoondyHub")
SaveManager:SetFolder("MoondyHub/Config")
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)

Library:SetWatermarkVisibility(true)
local FrameTimer = tick()
local FrameCounter = 0;
local FPS = 0;

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter += 1;
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter;
        FrameTimer = tick();
        FrameCounter = 0;
    end;
    Library:SetWatermark((' Moondy Hub | %s fps | %s ms'):format(math.floor(FPS), math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())));
end)

local MenuGroup = Tabs.Settings:AddLeftGroupbox("Menu Keybind", "wrench")
MenuGroup:AddLabel("Toggle UI"):AddKeyPicker("MenuKeybind", { Default = "K", NoUI = false, Text = "Open / Close", Mode = "Toggle" })

Library.ToggleKeybind = Options.MenuKeybind
Library:Notify("Loaded Moondy Hub! Press K to toggle.", 5)

SaveManager:LoadAutoloadConfig()
